/*
 * Astromech RSeries Controller for the R2 Builders Club
 *  
 * Creative Copyright v3 SA BY - 2012 Michael Erwin 
 *                               michael(dot)erwin(at)mac(dot)com 
 * 
 * RSeries Open Controller Project  http://code.google.com/p/rseries-open-control/
 * Requires Arduino 1.0 IDE
 *
 * Liberal use of code from the following: 
 * Tim Hirzel   http://www.growdown.com
 * Fabio Biondi http://www.fabiobiondi.com
 * Tod Kurt     http://todbot.com
 * Chad Philips http://www.windmeadow.com/node/42
 * Limor Fried  http://adafruit.com/
 * Gabriel Bianconi  http://www.gabrielbianconi.com/projects/arduinonunchuk/
 */

/* 
 Revision History
 v.0.7.0 - Replaced nunchuck library with my code
 v.0.6.1 - Rewrote menu system and other fixes.
 v.0.6.0 - Complete rewrite with legacy from old software and Skwerl's branch.
 v.0.5.1m  Mickes rewritten version
 
 Receive & displaying telemetry from the Receiver.
 Charging Status = Future
 Battery Status = Implemented
 Current Draw = Implemented
 Calculates an Estimated run time = Future
 
 Nunchuck I2C Configuration Information
 UNO:         Green I2C Data= A4, Yellow I2C Clock A5
 MEGA 2560:   Green I2C Data = C21, Yellow I2C Clock Pin C22
 
 The I2C output from Nunchuck is made up of 6 bytes and stored in outbuf
 0 Joystick X
 1 Joystick Y
 2 Accel X
 3 Accel Y
 4 Accel Z
 5 C & Z Buttons
 
 */
 
/*******************************************************************************************************/
/* Libraries                                                                                           */
/*******************************************************************************************************/

#include <Arduino.h>
#include <Adafruit_GFX.h>       // Core graphics library
#include <Adafruit_TFTLCD.h>    // Hardware-specific library
#include <TouchScreen.h>        // Touch Screen functions - adafruit.com @ https://github.com/adafruit/Touch-Screen-Library
#include <TFTLCD.h>             // TFT LCD functions - adafruit.com @ https://github.com/adafruit/TFTLCD-Library
#include <XBee.h>               
#include <Wire.h>               // Used to read the I2C data from Nunchuck


 /*******************************************************************************************************/
/* Config Stuff - make your changes here:                                                               */
/*******************************************************************************************************/

#define astromechName "R2-D2"
#define astromechOwner "Micke Askernas"
#define codeBranch "R-Series Controller"
#define codeVersion "0.7.0"
#define XBeeMSB 0x0013a200 //XBee Serial Number 
#define XBeeLSB 0x40913e21 //XBee Serial Number 
#define TUSCEN true // Set to 0 if you don't want to use the TUSCEN system.

boolean FastMode = false; // Start your droid in slow mode (recommended)

boolean TESTING=true; // bypass receiver telemetry before going into menu (DEBUG ONLY)

// Here is where you tweak your droid's turning speed!
// Note: Do not set any max or min value to 0, as that will only result in droid
// standing still, due to safeguard in case of packet loss.

// Normal Mode
int turnMinNorm = 40;
int turnMaxNorm = 140;
int driveMinNorm = 140;
int driveMaxNorm = 40;
int domeMinNorm = 138;
int domeMaxNorm = 42;

//Fast Mode
int turnMinFast = 24;
int turnMaxFast = 156;
int driveMinFast = 175;
int driveMaxFast = 5;
int domeMinFast = 150;
int domeMaxFast = 30;

// TUSCEN Config:

// Here we define what the Tusken Events will trigger
// TIER 1 Events: Events when Single button and direction are held

#define TEVENT1 17    // Top Button and Forward Held
#define TEVENT2 4    // Top Button and Right Held
#define TEVENT3 10    // Top Button and Reverse Held
#define TEVENT4 15    // Top Button and Left Held

#define TEVENT5 6    // Lower Button and Forward Held
#define TEVENT6 2    // Lower Button and Right Held
#define TEVENT7 11    // Lower Button and Reverse Held
#define TEVENT8 7    // Lower Button and Left Held


// TIER 2 Events: Events when Single button is held, beep, then direction
#define TEVENT9 54    // Top Button Held, Forward pushed
#define TEVENT10 58  // Top Button Held, Right pushed
#define TEVENT11 55  // Top Button Held, Reverse pushed
#define TEVENT12 56  // Top Button Held, Left pushed

#define TEVENT13 59  // Lower Button Held, Forward pushed
#define TEVENT14 61  // Lower Button Held, Right pushed
#define TEVENT15 60  // Lower Button Held, Reverse pushed
#define TEVENT16 62  // Lower Button Held, Left pushed


// TIER 1 Functions: Functions when Both buttonsand direction are held
#define TFUNCT1 65   // Both Buttons and Forward Held
#define TFUNCT2 39    // Both Buttons and Right Held
#define TFUNCT3 81    // Both Buttons and Reverse Held
#define TFUNCT4 38    // Both Buttons and Left Held


// TIER 2 Functions: Events when Both buttons are held, beep, then direction
#define TFUNCT5 63    // Both Buttons Held, Forward pushed
#define TFUNCT6 68    // Both Buttons Held, Right pushed
#define TFUNCT7 64    // Both Buttons Held, Reverse pushed
#define TFUNCT8 69    // Both Buttons Held, Left pushed



/*******************************************************************************************************/
/* Touch Screen Stuff                                                                                  */
/*******************************************************************************************************/

// Touch Screen Pin Configuration - Need to change A2 & A3, so as not to share
#define YM 9    // Y- (Minus) digital pin UNO = D9, MEGA = 9   // Orig 9
#define XM A8   // X- (Minus) must be an analog pin, use "An" notation! // Orig A2
#define YP A9   // Y+ (Plus)  must be an analog pin, use "An" notation! // Orig A3
#define XP 8    // X+ (Plus)  digital pin UNO = 8, MEGA = 8   // Orig 9

// These can be adjusted for greater precision 
#define TS_MINX 131 // Orig = 150
#define TS_MINY 120 // Orig = 120
#define TS_MAXX 920 // Orig = 920
#define TS_MAXY 950 // Orig = 940

#define rotation 3  // Which only changes the orientation of the LCD not the touch screen

uint16_t touchedY;
uint16_t touchedX;

int touchedRow;
int touchedCol;

unsigned long lastTouch = 0;
unsigned long touchWait = 800;			// Don't register a second touch event until X millis have passed

// For better pressure precision, we need to know the resistance
// between X+ and X- Use any multimeter to read it
// For the one we're using, its 300 ohms across the X plate
TouchScreen ts = TouchScreen(XP, YP, XM, YM, 380);    // Orig (XP, YP, XM, YM, 300) 

int sensitivity = 30;					// Default is 10

#define LCD_CS A3
#define LCD_CD A2
#define LCD_WR A1
#define LCD_RD A0 

#define LCD_RESET A4              // Use A4 to reset the Pin 7 of the TFT Display - Not Optional

// Color definitions
#define	BLACK           0x0000
#define	BLUE            0x001F
#define	RED             0xF800
#define	GREEN           0x07E0
#define CYAN            0x07FF
#define MAGENTA         0xF81F
#define YELLOW          0xFFE0 
#define WHITE           0xFFFF
#define WINE            0x8888
#define DRKBLUE         0x1111
#define TAN             0xCCCC
#define GRAY            0x038F

Adafruit_TFTLCD tft(LCD_CS, LCD_CD, LCD_WR, LCD_RD, LCD_RESET);


/*******************************************************************************************************/
/* Startup Check stuff                                                                                 */
/*******************************************************************************************************/

boolean presstocontinue=false;
boolean	controllerstatus=false;					// Nunchuk connected?
boolean	transmitterstatus=false;				// Are we transmitting?
boolean	receiverstatus=false;					// Are we networked?
boolean	telemetrystatus=false;					// Are we receiving telemetry?
boolean rxpacketvalid=false;
boolean rxpacketstart=false;
boolean txbegin=false;



/*******************************************************************************************************/
/* Menu Setup                                                                                          */
/*******************************************************************************************************/

// Things to choose from
typedef struct {
    String menuName;
    boolean itemToggle;
    String toggleName;
} menuChoices;

menuChoices menuItem[] = {  // DO NOT CHANGE THESE. YOUR OWN MENU IS BELOW. THESE ARE OPTIONS!
    {"1234567890123", false, ""    },               // 0
    {"Happy SFX",     false, ""    },               // 1
    {"Annoyed",       false, ""    },               // 2
    {"Rnd Whistle",   false, ""    },               // 3
    {"Processing",    false, ""    },               // 4
    {"Humming",       false, ""    },               // 5
    {"Scream",        false, ""    },               // 6
    {"Sys Failure",   false, ""    },               // 7
    {"Razzberry",     false, ""    },               // 8
    {"Wolf Whistle",  false, ""    },               // 9
    {"Ooooh!",        false, ""    },               // 10
    {"Alarm Sequenc", false, ""    },               // 11
    {"Fire Extngshr", false, ""    },               // 12
    {"Dance Cantina", false, ""    },               // 13
    {"CPU Arm Out",   true, "CPU Arm In"    },      // 14 Body_CPU
    {"Leia HP Short", false, ""    },               // 15
    {"Leia HP Long",  false, ""    },               // 16
    {"Wiggle",        false, ""    },               // 17
    {"Flirt",         false, ""    },               // 18
    {"Dome Open",     true, "Dome Close"    },      // 19 Dome_Open
    {"Dome Wave",     false, ""    },               // 20
    {"Dance Disco",   false, ""    },               // 21
    {"Launch Saber",  false, ""    },               // 22
    {"Start LFS",     true, "Stop LFS"    },        // 23 Dome_LFS
    {"Start P-scope", true, "Stop P-scope"    },    // 24 Dome_Periscope
    {"Start HP 1",    true, "Stop HP 1"    },       // 25 Dome_HP1
    {"Start HP 2",    true, "Stop HP 2"    },       // 26 Dome_HP2
    {"Start HP 3",    true, "Stop HP 3"    },       // 27 Dome_HP3
    {"Open PP1",      true, "Close PP1"    },       // 28 Dome_PP1
    {"Open PP2",      true, "Close PP2"    },       // 29 Dome_PP2
    {"Open PP3",      true, "Close PP3"    },       // 30 Dome_PP3
    {"Open PP4",      true, "Close PP4"    },       // 31 Dome_PP4
    {"Open Dpan1",    true, "Close Dpan1"    },     // 32 Dome_Panel1
    {"Open Dpan2",    true, "Close Dpan2"    },     // 33 Dome_Panel2
    {"Open Dpan3",    true, "Close Dpan3"    },     // 34 Dome_Panel3
    {"Open Dpan4",    true, "Close Dpan4"    },     // 35 Dome_Panel4
    {"Open Dpan5",    true, "Close Dpan5"    },     // 36 Dome_Panel5
    {"Open Dpan6",    true, "Close Dpan6"    },     // 37 Dome_Panel6
    {"Open CBI",      true, "Close CBI"    },       // 38 Body_CBI
    {"Open Datapan",  true, "Close Datapan"    },   // 39 Body_Datapanel
    {"Open Door L",   true, "Close Door L"    },    // 40 Body_Door_L
    {"Open Door R",   true, "Close Door R"    },    // 41 Body_Door_R
    {"Vader!",        false, ""    },               // 42
    {"C3PO",          false, ""    },               // 43
    {"Yoda",          false, ""    },               // 44
    {"Luke",          false, ""    },               // 45
    {"Leia",          false, ""    },               // 46
    {"Han Solo",      false, ""    },               // 47
    {"Obi-Wan",       false, ""    },               // 48
    {"Chewbacca",     false, ""    },               // 49
    {"Jawas",         false, ""    },               // 50
    {"Anakin",        false, ""    },               // 51
    {"Jabba's Place", false, ""    },               // 52
    {"Ahsoka Tano",   false, ""    },               // 53
    {"Play Theme",    false, ""    },               // 54
    {"Play March",    false, ""    },               // 55
    {"Play Cantina",  false, ""    },               // 56
    {"Cantina Short", false, ""    },               // 57
    {"Play Duel",     false, ""    },               // 58
    {"Play Disco",    false, ""    },               // 59
    {"Play Remix",    false, ""    },               // 60
    {"Play Cello",    false, ""    },               // 61
    {"Cantina Inter", false, ""    },               // 62
    {"Lock Dome",     true, "Unlock Dome"    },     // 63 Dome_Lock
    {"Lock Drive",    true, "Unlock Drive"    },    // 64 Drive_Lock
    {"Stealth On",    true, "Stealth Off"    },     // 65 StealthMode
    {"Race Mode",     true, "Race End"    },        // 66 RaceMode
    {"Patrol Mode",   true, "Patrol Off"    },      // 67 PatrolMode
    {"Alt Control",   true, "Norml Control"    },   // 68 AltControl
    {"Fast Mode",     true, "Normal Speed"    },    // 69 FastMode
    {"Funny Mode",    true, "End Funny"    },       // 70 FunnyMode
    {"Auto Pilot",    true, "Manual Pilot"    },    // 71 AutoPilot    
    {"Reset Dome",    false, ""    },               // 72
    {"Reset Recvr",   false, ""    },               // 73
    {"Reset Control", false, ""    },               // 74
    {"Reset All",     false, ""    },               // 75
    {"Reset FX1",     false, ""    },               // 76
    {"Reset FX2",     false, ""    },               // 77
    {"Reset FX3",     false, ""    },               // 78
    {"Reset FX4",     false, ""    },               // 79
    {"Reset FX5",     false, ""    },               // 80
    {"Power Off",     true, "Power On"    },        // 81 PowerOff
    // Add more here
    {"Play Patrol",   false, ""   }                 // 82    
};

// MY own menu with my own choices, taken from the large, unchangeable list above
int myMenu[] = { 
    11,   // Alarm Sequence
    7,    // System Failure
    6,    // Scream
    10,   // Oooh
    4,    // Processing
    3,    // Whistle
    15,   // Leia HP Short
    8,    // Razzberry
    5,    // Humming

    54,   // Play Theme
    55,   // Play Imperial March
    56,   // Play Cantina Band
    59,   // Play Star Wars Disco
    58,   // Play Duel of the Fates
    60,   // Play Star Wars Remix
    61,   // Play Cello wars
    62,   // Play Cantina Interactive
    16,   // Play Leia Long

    71,   // AutoPilot
    63,   // Dome Lock
    64,   // Drive Lock
    69,   // Fast Mode
    68,   // Alternative Control
    65,   // Stealth Mode
    67,   // Patrol Mode
    66,   // Race Mode
    70,   // Funny Mode

    81,   // Power Off
    38,   // Body CBI
    39,   // DataPanel
    25,   // HP 1
    26,   // HP 2
    27,   // HP 3    
    18,   // Flirt
    40,   // Door Left
    41    // Door Right    
};

int curPage = 1;
unsigned int startAt;
int boxesPerRow = 3;
int rowsPerPage = 3;
int itemsPerPage = boxesPerRow*rowsPerPage;
int menuPages=(sizeof(myMenu)/sizeof(char *))/itemsPerPage;
int boxWidth = 104;
int boxHeight = 58;
int boxMargin = 4;



/*******************************************************************************************************/
/* TUSCEN stuff                                                                              */
/*******************************************************************************************************/

#define TTIME 500     // Time needed for button to be considered held.
#define TTIMEOUT 1500  // Time needed after button held + beep until timeout.
#define STICKGAP 10    // How far from center position is considered a direction

boolean tuscenEventCheck = false;  // boolean to check if we have triggered a normal even or a TUSCEN[tm] Event.
boolean zbutPressed = false;
boolean cbutPressed = false;
boolean tuscenTier2Wait = false;

unsigned long triggerEventStart = millis();



/*******************************************************************************************************/
/* XBee Stuff                                                                                          */
/*******************************************************************************************************/

int xbeebps = 19200;
uint8_t payload[] = { '0', '0', '0', '0', };  
Rx16Response rx16 = Rx16Response();
XBee xbee = XBee();
XBeeResponse response = XBeeResponse();

// Create reusable response objects for responses we expect to handle 
ZBRxResponse rx = ZBRxResponse();
ModemStatusResponse msr = ModemStatusResponse();
 
XBeeAddress64 addr64 = XBeeAddress64(XBeeMSB, XBeeLSB); // Destination (Receiver) address
ZBTxRequest zbTx = ZBTxRequest(addr64, payload, sizeof(payload));
ZBTxStatusResponse txStatus = ZBTxStatusResponse();

uint8_t shCmd[] = {'S','H'};
uint8_t slCmd[] = {'S','L'};
uint8_t opCmd[] = {'O','P'};

AtCommandRequest atRequest = AtCommandRequest(opCmd);
AtCommandResponse atResponse = AtCommandResponse();

int xbATResponse = 0xFF;			// To verify Coordinator XBee is setup and ready, set to 0xFF to prevent false positives
int xbeeTimeout=50;



/*******************************************************************************************************/
/* Telemetry                                                                                           */
/*******************************************************************************************************/

byte telemetryflags1, telemetryflags2, telemetryflags3, telemetryflags4;
byte lastTelemetry1, lastTelemetry2, lastTelemetry3, lastTelemetry4;

int telemetry1[] = {63, 64, 65, 66, 67, 68, 69, 71};
int telemetry2[] = {70, 81, 14, 38, 39, 40, 41, 0};
int telemetry3[] = {25, 26, 27, 28, 29, 30, 31, 19};
int telemetry4[] = {23, 24, 32, 33, 34, 35, 36, 37};

char setFlags[99];

boolean toggled;

byte txSignature = 0;
byte rxSignature = 0;
byte rxResponded = 0;
byte lastSigSent = txSignature;

int signalCode = 0;						// 0:  No Radio
								// 1:  Radio OK
								// 2:  Sending Signal											// 3:  Signal Received
								// -1: Signal Timeout

int signalTimeout = 3000;					// How long do we wait for signal to be received?
unsigned long signalLastSent = 0;
unsigned long signalNextMilli = 0;
unsigned long lastTransmission = 0;

int updateStatusDelay = 3500;					// Update Status Bar Display every 3500ms (3.5 Seconds), caution on reducing
unsigned long nextStatusBarUpdate = 0;

int analogVCCinput = 5;						// RSeries Controller default VCC input is A5
float R1 = 47000.0;						// >> resistance of R1 in ohms << the more accurate these values are
float R2 = 24000.0;						// >> resistance of R2 in ohms << the more accurate the measurement will be

/* CONTROLLER BATTERY */

unsigned int txVCC = 0;
unsigned int txVCA = 0;
float txVCCout;							// Display variable for Voltage from Receiver
float txVCAout;							// Display variable for Amperage from Receiver

/* TELEMETRY FROM RECEIVER */

int rxRssi;
int rssiMin = 90;
int rssiMax = 40;

unsigned int rxVCC;
unsigned int rxVCA;
float rxVCCout;							// Display variable for Voltage from Receiver
float rxVCAout;							// Display variable for Amperage from Receiver

float vinSTRONG = 3.4;						// If vin is above vinSTRONG display GREEN battery
float vinWEAK = 2.9;						// if vin is above vinWEAK display YELLOW otherwise display RED
float vinDANGER = 2.7;		



/*******************************************************************************************************/
/* Wii nunchuk stuff                                                                                   */
/*******************************************************************************************************/

//ArduinoNunchuk nunchuk = ArduinoNunchuk();
//byte joyx, joyy, accx, cbut, zbut, drive, turn, dome;
byte joyx, joyy, accx, cbut, zbut, drive, turn, dome;

byte triggerEvent;

int turnMin, turnMax, driveMin, driveMax, domeMin, domeMax;
// The controller is in charge of taking the nunchuk values and translate them to a value the
// receiver can understand. Less the receiver does, the better.

int joyx=90;
int joyy=90;
int accx=90;
int cbut=0;
int zbut=0;

int joyxMin = 90;
int joyxMax = 90;
int joyyMin = 90;
int joyyMax = 90;
int accxMin = 90;
int accxMax = 90;

//int servoMin = 0;
//int servoMax = 180;
//
//int joyxCenter = 90;
//int joyyCenter = 90;


/*******************************************************************************************************/
/* Variables and booleans                                                                              */
/*******************************************************************************************************/

// Triggers. Things that can be toggled on and off and we need to keep track of.
boolean Body_CPU = false;
boolean Dome_Open = false;
boolean Dome_LFS = false;
boolean Dome_Periscope = false;
boolean Dome_HP1 = false;
boolean Dome_HP2 = false;
boolean Dome_HP3 = false;
boolean Dome_PP1 = false;
boolean Dome_PP2 = false;
boolean Dome_PP3 = false;
boolean Dome_PP4 = false;
boolean Dome_Panel1 = false;
boolean Dome_Panel2 = false;
boolean Dome_Panel3 = false;
boolean Dome_Panel4 = false;
boolean Dome_Panel5 = false;
boolean Dome_Panel6 = false;
boolean Body_CBI = false;
boolean Body_Datapanel = false;
boolean Body_Door_L = false;
boolean Body_Door_R = false;
boolean Dome_Lock = false;
boolean Drive_Lock = false;
boolean StealthMode = false;
boolean RaceMode = false;
boolean PatrolMode = false;
boolean AltControl = false;
boolean FunnyMode = false;
boolean PowerOff = false;
boolean AutoPilot = false;


/*******************************************************************************************************/
/* setup()                                                                                             */
/*******************************************************************************************************/

void setup() {
    Serial.begin(9600);                                         // DEBUG CODE
    Serial.print("Menu pages: ");Serial.println(menuPages);
    
    triggerEventStart = millis();

    
    Serial1.begin(xbeebps);
    xbee.setSerial(Serial1);				// Setup Xbee to use Serial1
    xbee.begin(xbeebps);					// Setup Xbee to begin at 19200
	
    pinMode(analogVCCinput, INPUT);

    tft.reset();                                                // A4 must be connected to TFT Break out Pin 7
    uint16_t identifier = tft.readRegister(0x0);
    if (identifier == 0x9325) {
        Serial.println("Found ILI9325");
    } else if (identifier == 0x9328) {
	Serial.println("Found ILI9328");
    } else if (identifier == 0x7575) {
        Serial.println("Found HX8347G");
    } else {
        Serial.print("Unknown driver chip ");
        Serial.println(identifier, HEX);
        while (1);
    }  
    tft.begin(identifier);
    tft.setRotation(rotation); 
    tft.fillScreen(BLACK);

    initNunchuck(); // initializing Nunchuck Micke Style!
    bootTests();
    tft.fillScreen(BLACK);

    setToggleFlags();
    updateStatus();
    updateGrid();

}



/*******************************************************************************************************/
/* loop()                                                                                             */
/*******************************************************************************************************/

void loop(){
    
    getVCC();
    RXdata();
    
//    nunchuk.update();                // ALL data from nunchuk is continually sent to Receiver
    getNunchuckData();
    
    if (FastMode) {
        turnMin = turnMinFast;
        turnMax = turnMaxFast;
        driveMin = driveMinFast;
        driveMax = driveMaxFast;
        domeMin = domeMinFast;
        domeMax = domeMaxFast;
    } else {
        turnMin = turnMinNorm;
        turnMax = turnMaxNorm;
        driveMin = driveMinNorm;;
        driveMax = driveMaxNorm;;
        domeMin = domeMinNorm;;
        domeMax = domeMaxNorm;;
    }
    
    // just assigning joyx, joyy and accx for now. We will decide what to do with them in a minute.
//    joyx = map(nunchuk.analogX, joyxMin, joyxMax, servoMin, servoMax); // Channel 1 joyx & Channel 2 joyy from NunChuck Joystick
//    joyy = map(nunchuk.analogY, joyyMin, joyyMax, servoMin, servoMax); // Map it to Min & Max of each channel
//    if (nunchuk.accelX < accxMin) { 
//        accx = servoMin;
//    }
//    else if (nunchuk.accelX > accxMax) { 
//        accx = servoMax;
//    }
//    else accx = map(nunchuk.accelX, accxMin, accxMax, servoMin, servoMax);
    
    //we are keeping 'servo vaues' of joyx, joyy due to TUSCEN checks.
    
    // Now we have the values, let's map them to proper values.
    if (AltControl) {                         // we're doing all steering with the joystick
        turn = map(joyx, joyxMin, joyxMax, turnMin, turnMax);
        dome = map(accx, accxMin, accxMax, domeMin, domeMax);
    } else {                                 // normal steering
        turn = map(accx, accxMin, accxMax, turnMin, turnMax);
        dome = map(joyx, joyxMin, joyxMax, domeMin, domeMax);
    }
    drive = map(joyy, joyyMin, joyyMax, driveMin, driveMax);
           
    zbut = nunchuk.zButton; // either 0 or 1
    cbut = nunchuk.cButton; // either 0 or 1
    
/*******************************************************************************************************/
/* TUSCEN block                                                                                        */
/*******************************************************************************************************/
    

    if (!TUSCEN) {
        if (zbut == 1 && cbut == 0) {
            triggerEvent = 101; 
            TXdata();
        }
        else if (zbut == 0 && cbut == 1) {
            triggerEvent = 102; 
            TXdata();
        }
        else if (zbut == 1 && cbut == 1) {
            triggerEvent = 103; 
            TXdata();
        }
    } 
    else {

        if (((joyx!=90) || (joyy!=90)) && !tuscenEventCheck) { // We are driving. Button pressed will be treated as a click regardless.
            if (zbut == 1 && cbut == 0) {
                triggerEvent = 101; 
                TXdata();
            }
            else if (zbut == 0 && cbut == 1) {
                triggerEvent = 102; 
                TXdata();
            }
            else if (zbut == 1 && cbut == 1) {
                triggerEvent = 103; 
                TXdata();
            }
        } 
        else { // We're not driving. We can trigger a TUSCEN[tm] Event.  
            if (zbut == 1 && cbut == 0) {
                if (!tuscenEventCheck) { //This is a new triggercheck for TUSCEN[tm] Event.
                    triggerEventStart = millis();
                    zbutPressed = true;  // Remember which button was pressed in case we will just trigger the event.
                    cbutPressed = false;
                    tuscenEventCheck = true;
                } 
                else { // If we are already inside a tuscenEventCheck and button is pressed.
                    if (!tuscenTier2Wait) {
                        if (triggerEventStart + TTIME < millis()) { // TTIME reached, time to go to the next level!
                            if (joyx < (joyxCenter-STICKGAP)) {
                                triggerEvent=TEVENT8; 
                                TXdata(); 
                                resetTuscen();
                            }
                            else if (joyy > (joyyCenter+STICKGAP)) {
                                triggerEvent=TEVENT7; 
                                TXdata(); 
                                resetTuscen();
                            }        
                            else if (joyx > (joyxCenter+STICKGAP)) {
                                triggerEvent=TEVENT6; 
                                TXdata(); 
                                resetTuscen();
                            }
                            else if (joyy < (joyyCenter-STICKGAP)) {
                                triggerEvent=TEVENT5; 
                                TXdata(); 
                                resetTuscen();
                            } 
                            else { // No direction pressed, time to go into the second round of timeouts!
                                if (!tuscenTier2Wait) {
                                    Serial.println("Going to TIER 2");
                                    tuscenTier2Wait = true;
                                    triggerEvent = 254;   // Sending Beep
                                    TXdata();           // Sending Beep
                                }
                            }            
                        }  
                    }
                }
            } 
            else if (zbut == 0 && cbut == 1) {
                if (!tuscenEventCheck) { //This is a new triggercheck for TUSCEN[tm] Event.
                    triggerEventStart = millis();
                    zbutPressed = false;  // Remember which button was pressed in case we will just trigger the event.
                    cbutPressed = true;
                    tuscenEventCheck = true;
                } 
                else { // If we are already inside a tuscenEventCheck and button is pressed.
                    if (!tuscenTier2Wait) {
                        if (triggerEventStart + TTIME < millis()) { // TTIME reached, time to go to the next level!
                            if (joyx < (joyxCenter-STICKGAP)) {
                                triggerEvent=TEVENT4; 
                                TXdata(); 
                                resetTuscen();
                            }
                            else if (joyy > (joyyCenter+STICKGAP)) {
                                triggerEvent=TEVENT3; 
                                TXdata(); 
                                resetTuscen();
                            }        
                            else if (joyx > (joyxCenter+STICKGAP)) {
                                triggerEvent=TEVENT2; 
                                TXdata(); 
                                resetTuscen();
                            }
                            else if (joyy < (joyyCenter-STICKGAP)) {
                                triggerEvent=TEVENT1; 
                                TXdata(); 
                                resetTuscen();
                            } 
                            else { // No direction pressed, time to go into the second round of timeouts!
                                if (!tuscenTier2Wait) {
                                    Serial.println("Going to TIER 2");
                                    tuscenTier2Wait = true;
                                    triggerEvent = 254;   // Sending Beep
                                    TXdata();           // Sending Beep
                                }
                            }            
                        }  
                    }
                }
            } 
            else if (zbut == 1 && cbut == 1) {
                if (!tuscenEventCheck) { //This is a new triggercheck for TUSCEN[tm] Event.
                    triggerEventStart = millis();
                    zbutPressed = true;  // Remember which button was pressed in case we will just trigger the event.
                    cbutPressed = true;
                    tuscenEventCheck = true;
                } 
                else { // If we are already inside a tuscenEventCheck and button is pressed.
                    if (!tuscenTier2Wait) {
                        if (triggerEventStart + TTIME < millis()) { // TTIME reached, time to go to the next level!
                            if (joyx < (joyxCenter-STICKGAP)) {
                                triggerEvent=TFUNCT1; 
                                TXdata(); 
                                resetTuscen();
                            }
                            else if (joyy > (joyyCenter+STICKGAP)) {
                                triggerEvent=TFUNCT2; 
                                TXdata(); 
                                resetTuscen();
                            }        
                            else if (joyx > (joyxCenter+STICKGAP)) {
                                triggerEvent=TFUNCT3; 
                                TXdata(); 
                                resetTuscen();
                            }
                            else if (joyy < (joyyCenter-STICKGAP)) {
                                triggerEvent=TFUNCT4; 
                                TXdata(); 
                                resetTuscen();
                            } 
                            else { // No direction pressed, time to go into the second round of timeouts!
                                if (!tuscenTier2Wait) {
                                    Serial.println("Going to TIER 2");
                                    tuscenTier2Wait = true;
                                    triggerEvent = 254;   // Sending Beep
                                    TXdata();           // Sending Beep
                                }
                            }            
                        }  
                    }
                }
            } 
            else if (tuscenEventCheck && !tuscenTier2Wait) { // tuscenEvent is active, but no button pressed: Send normal command.
                if (zbutPressed && !cbutPressed) {
                    triggerEvent = 101; 
                    TXdata();
                }
                if (!zbutPressed && cbutPressed) {
                    triggerEvent = 102; 
                    TXdata();
                }
                if (zbutPressed && cbutPressed) {
                    triggerEvent = 103; 
                    TXdata();
                }    
                resetTuscen();
            } 
        }
        if (tuscenTier2Wait == true) {
            if (triggerEventStart + TTIME + TTIMEOUT > millis()) { // Timeout not yet reached.
                if (zbutPressed && !cbutPressed) {
                    if (joyx < (joyxCenter-STICKGAP)) {
                        triggerEvent=TEVENT16;
                        TXdata();
                        resetTuscen();
                    }
                    else if (joyy > (joyyCenter+STICKGAP)) {
                        triggerEvent=TEVENT15; 
                        TXdata(); 
                        resetTuscen();
                    }        
                    else if (joyx > (joyxCenter+STICKGAP)) {
                        triggerEvent=TEVENT14; 
                        TXdata(); 
                        resetTuscen();
                    }
                    else if (joyy < (joyyCenter-STICKGAP)) {
                        triggerEvent=TEVENT13; 
                        TXdata(); 
                        resetTuscen();
                    }
                }
                if (!zbutPressed && cbutPressed) {
                    if (joyx < (joyxCenter-STICKGAP)) {
                        triggerEvent=TEVENT12; 
                        TXdata(); 
                        resetTuscen();
                    }
                    else if (joyy > (joyyCenter+STICKGAP)) {
                        triggerEvent=TEVENT11; 
                        TXdata(); 
                        resetTuscen();
                    }        
                    else if (joyx > (joyxCenter+STICKGAP)) {
                        triggerEvent=TEVENT10; 
                        TXdata(); 
                        resetTuscen();
                    }
                    else if (joyy < (joyyCenter-STICKGAP)) {
                        triggerEvent=TEVENT9; 
                        TXdata(); 
                        resetTuscen();
                    }
                }
                if (zbutPressed && cbutPressed) {
                    if (joyx < (joyxCenter-STICKGAP)) {
                        triggerEvent=TFUNCT8; 
                        TXdata(); 
                        resetTuscen();
                    }
                    else if (joyy > (joyyCenter+STICKGAP)) {
                        triggerEvent=TFUNCT7; 
                        TXdata(); 
                        resetTuscen();
                    }        
                    else if (joyx > (joyxCenter+STICKGAP)) {
                        triggerEvent=TFUNCT6; 
                        TXdata(); 
                        resetTuscen();
                    }
                    else if (joyy < (joyyCenter-STICKGAP)) {
                        triggerEvent=TFUNCT5; 
                        TXdata(); 
                        resetTuscen();
                    }
                }

            } 
            else { // Timeout has been reached
                resetTuscen();
                triggerEvent = 254;   // Sending Beep
                TXdata();           // Sending Beep
            }        
        }
    }

/*******************************************************************************************************/
/* END TUSCEN block                                                                                    */
/*******************************************************************************************************/

    if ((telemetryflags1 != lastTelemetry1) || (telemetryflags2 != lastTelemetry2) || (telemetryflags3 != lastTelemetry3) || (telemetryflags4 != lastTelemetry4)) {
        setToggleFlags();
        updateGrid();
    }
    
    getTouch();
    TXdata();
    updateSignal();
    checkPulse();

    if (millis() >= nextStatusBarUpdate) {
        updateStatus();
    }

}



/*******************************************************************************************************/
/* Other functions()                                                                                             */
/*******************************************************************************************************/

void updateGrid() {

    unsigned int i;
    int xOffset = 0;
    int yOffset = 30;
    int colIndex = 1;
    int buttonId;

    	startAt = ((curPage-1)*itemsPerPage);
//    startAt = 0;

    tft.fillRect(0, 21, 320, 220, BLACK);

    // Render Pagination
    tft.fillRect(0, 220, 130, 20, WHITE);
    tft.fillRect(190, 220, 130, 20, WHITE);
    tft.fillTriangle(5,230, 25,225, 25,235, BLACK);
    tft.fillTriangle(315,230, 295,225, 295,235, BLACK);
    tft.setCursor(150, 222);
    tft.setTextColor(WHITE);
    tft.setTextSize(2);
    tft.println(pad(curPage,2));

    for (i=startAt; i<(startAt+itemsPerPage); i++) {


        if ((i >= sizeof(myMenu)) || (i>251)) { 
            break; 
        }

        xOffset = (colIndex-1)*(boxMargin+boxWidth);


        buttonId = i+1;

        for (unsigned int j=0; j<=sizeof(setFlags); j++) {
            if (myMenu[i] == setFlags[j]) {
                toggled = true;
                break;
            } 
            else {
                toggled = false;
            }
        }       

        tft.setCursor((xOffset+10), (yOffset+((boxHeight/2)-4)));
        tft.setTextColor(WHITE);
        tft.setTextSize(1);
        if (toggled) {
            tft.println(menuItem[myMenu[i]].toggleName);
            tft.drawRect(xOffset, yOffset, boxWidth, boxHeight, RED);                    
        } 
        else {
            tft.println(menuItem[myMenu[i]].menuName);
            tft.drawRect(xOffset, yOffset, boxWidth, boxHeight, BLUE);
        }

        colIndex++;
        if (colIndex > boxesPerRow) {
            colIndex = 1;
            yOffset = yOffset+boxMargin+boxHeight;
        }

    }

}

String pad(int number, byte width) {
    String output;
    int currentMax = 10;
    for (byte i=1; i<width; i++) {
        if (number < currentMax) {
            output += "0";
        }
        currentMax *= 10;
    } 
    output += String(number);
    //Serial.print("output: ");
    //Serial.println(output);
    return output;
}

void setToggleFlags() {
    for (int i=0;i<8;i++) {
        if (bitRead(telemetryflags1,i)) setFlags[i] = telemetry1[i];
        else setFlags[i] = 0;
    }
    for (int i=0;i<8;i++) {
        if (bitRead(telemetryflags1,i)) setFlags[i+8] = telemetry2[i];
        else setFlags[i+8] = 0;
    }
    for (int i=0;i<8;i++) {
        if (bitRead(telemetryflags1,i)) setFlags[i+16] = telemetry2[i];
        else setFlags[i+16] = 0;
    }
    for (int i=0;i<8;i++) {
        if (bitRead(telemetryflags1,i)) setFlags[i+24] = telemetry2[i];
        else setFlags[i+24] = 0;
    }
    lastTelemetry1 = telemetryflags1;
    lastTelemetry2 = telemetryflags2;
    lastTelemetry3 = telemetryflags3;
    lastTelemetry4 = telemetryflags4;
}

void bootTests() {

	tft.setCursor(0,0);
	tft.setTextColor(WHITE);
	tft.setTextSize(2);
	tft.print(codeBranch);
	tft.print(" ");
	tft.print(codeVersion);

	tft.setTextSize(1);
	tft.setCursor(0,20);
	tft.print("Astromech: ");
	tft.print(astromechName);
	tft.setCursor(0,30);
	tft.print("Builder: ");
	tft.print(astromechOwner);

	tft.setTextColor(GREEN);
	tft.setTextSize(2);
	
	/* BOOT TEST SEQUENCE */

	tft.setCursor(20,60);
	tft.println("Wii Nunchuk:");
	tft.setCursor(220,60);
	tft.setTextColor(RED);
	tft.println("...");
	
	boolean controlleralive = false;
	
	while(controllerstatus == false) {
		nunchuk.update();				// ALL data from nunchuk is continually sent to Receiver
		joyx = nunchuk.analogX;				// ranges from approx 30 - 220
		joyy = nunchuk.analogY;				// ranges from approx 29 - 230
		accx = nunchuk.accelX;				// ranges from approx 70 - 182
//		accy = nunchuk.accelY;				// ranges from approx 65 - 173
//		accz = nunchuk.accelZ;				// ranges from approx 65 - 173
		zbut = nunchuk.zButton;				// either 0 or 1
		cbut = nunchuk.cButton;				// either 0 or 1
		if (joyx > 0 && joyy > 0) {
			if (!controlleralive) {
				tft.fillRect(220,60,100,17,BLACK);
				tft.setCursor(220,60);
				tft.println("Locked");
				controlleralive = true;
			}
		}
		if (zbut==1 && cbut==1) {
			controllerstatus = true;
		}
	}
	
	tft.fillRect(220,60,100,17,BLACK);			// Clear Waiting Message
	tft.setCursor(220,60);
	tft.setTextColor(GREEN);
	tft.println("OK!");
	
	tft.setTextColor(GREEN);
	tft.setCursor(20,80);
	tft.println("Transmitter:");
	tft.setCursor(220,80);
	tft.setTextColor(RED);
	tft.println("...");
	
	while(transmitterstatus == false) {
		xbeeSL();					// Send an AT command via API mode
		Serial.print("xbATResponse = ");		// DEBUG CODE
		Serial.println(xbATResponse, HEX);		// DEBUG CODE
		if (xbATResponse == 0x00) {			// to verify Coordinator XBee is setup and ready.
			signalCode = 1;
			transmitterstatus = true;
			Serial.println("Transmitter Status Good");	// DEBUG CODE
		}
	}
	
	tft.fillRect(220, 80, 100, 17, BLACK);
	tft.setCursor(220,80);
	tft.setTextColor(GREEN);
	tft.println("OK!");  

	tft.setCursor(20,100);
	tft.setTextColor(GREEN);
	tft.println("Receiver:");
	tft.setCursor(220,100);
	tft.setTextColor(RED);
	tft.println("Pinging");
//DEBUG
    if (TESTING) {
        receiverstatus=true;
        telemetrystatus=true;
    }
//END DEBUG
	while(receiverstatus == false) {
		payload[0] = byte(0x90);			// joyx
		payload[1] = byte(0x90);			// joyy
		payload[2] = byte(0x90);			// accx
//		payload[3] = byte(0x90);			// accy
//		payload[4] = byte(0x90);			// accz
//		payload[3] = byte(0x00);			// zButton
//		payload[4] = byte(0x00);			// cButton
		payload[3] = byte(0x00);			// TriggerEvent
//		payload[8] = byte(0x00);			// Future Use
		xbee.send(zbTx);				// Send a Test Payload to Receiver
		Serial.println("Sending test payload...");	// DEBUG CODE
		if (xbee.readPacket(500)) {
			if (xbee.getResponse().getApiId() == ZB_TX_STATUS_RESPONSE) {
				xbee.getResponse().getZBTxStatusResponse(txStatus);
				if (txStatus.getDeliveryStatus() == SUCCESS) {
					receiverstatus = true;
				} else {
					// Packet not received...
				}
			}
		} else if (xbee.getResponse().isError()) {
			// Error reading packet...
		} else {
			// TX status timeout...
		}
//		delay(1000);
	}
	Serial.println("Receiver Responded...");   // DEBUG CODE
	tft.fillRect(220, 100, 100, 17, BLACK);
	tft.setCursor(220,100);
	tft.setTextColor(GREEN);
	tft.println("OK!");  

	// Looking for the Volts & Amperage from Receiver (Router)
	tft.setTextColor(GREEN);
	tft.setCursor(20,120);
	tft.println("Telemetry:");
	tft.setCursor(220,120);
	tft.setTextColor(RED);
	tft.println("...");

	while(telemetrystatus == false) {
		RXdata();
		//Serial.print("POST Received Telemetry -->> rxVCC =");
		//Serial.print(rxVCC);
		//Serial.print("\trxVCA =");Serial.println(rxVCA);
		if (rxVCC > 0 && rxVCA > 0) {
			telemetrystatus = true;
			signalCode = 1;
		}
	}
	
	tft.fillRect(220, 120, 100, 17, BLACK);// Clear Waiting Message
	tft.setCursor(220,120);
	tft.setTextColor(GREEN);
	tft.println("OK!");  
	
//	delay(1000);

}

void updateStatus() {

	tft.setCursor(18, 3);
	tft.setTextColor(WHITE);
	tft.setTextSize(2);
	tft.println(astromechName);
	tft.drawFastHLine(0, 19, tft.width(), WHITE);

	updateRSSI();
	updateBattery(180,txVCCout,"TX");
	updateBattery(242,rxVCCout,"RX");

	nextStatusBarUpdate = millis() + updateStatusDelay;

}

void updateRSSI() {

	int bars = map(rxRssi, rssiMin, rssiMax, 0, 5);

	//Serial.print("RSSI bars: ");
	//Serial.print(bars);
	//Serial.print(" (RSSI value was ");
	//Serial.print(rxRssi);
	//Serial.println(")");

	tft.fillRect(298, 2, 22, 17, BLACK);

	tft.drawFastVLine(298, 14, 2, GRAY);
	tft.drawFastVLine(299, 14, 2, GRAY);
	
	tft.drawFastVLine(303, 12, 4, GRAY);
	tft.drawFastVLine(304, 12, 4, GRAY);
	
	tft.drawFastVLine(308, 10, 6, GRAY);
	tft.drawFastVLine(309, 10, 6, GRAY);
	
	tft.drawFastVLine(313, 7, 9, GRAY);
	tft.drawFastVLine(314, 7, 9, GRAY);
	
	tft.drawFastVLine(318, 3, 13, GRAY);
	tft.drawFastVLine(319, 3, 13, GRAY);
	
	if (bars>=1) {
		tft.drawFastVLine(298, 14, 2, WHITE);			// Signal =1 
		tft.drawFastVLine(299, 14, 2, WHITE);
	}  
	if (bars>=2) {
		tft.drawFastVLine(303, 12, 4, WHITE);			// Signal =2
		tft.drawFastVLine(304, 12, 4, WHITE);
	}
	if (bars>=3) {
		tft.drawFastVLine(308, 10, 6, WHITE);			// Signal =3 
		tft.drawFastVLine(309, 10, 6, WHITE);
	}
	if (bars>=4) {
		tft.drawFastVLine(313, 7, 9, WHITE);			// Signal =4 
		tft.drawFastVLine(314, 7, 9, WHITE);
	}
	if (bars>=5) {
		tft.drawFastVLine(318, 3, 13, WHITE);			// Signal =5 
		tft.drawFastVLine(319, 3, 13, WHITE);
	}

	if (bars<1) {
		signalCode = 0;
	} else {
		if (signalCode < 2) {
			signalCode = 1;
		}
	}

}

void updateBattery(int battx, float vcc, String display) {

	int battIcon = battx+27;

	tft.fillRect(battIcon, 0, 9, 17, BLACK);       				// Erase Battery Status area
	
	// Draw the battery outline in white
	tft.drawFastHLine((battIcon+2), 0, 4, WHITE);				// This is the little top of the battery
	tft.drawFastHLine((battIcon+2), 1, 4, WHITE);
	tft.drawRect(battIcon, 2, 8, 15, WHITE);					// Body of the battery
	
	if (vcc >= vinSTRONG) {   
		tft.fillRect((battIcon+1), 3, 6, 14, GREEN);			// If Battery is strong then GREEN  
	} else if (vcc >=vinWEAK) {
		tft.fillRect((battIcon+1), 8, 6, 9, YELLOW);			// If Battery is medium then YELLOW
	} else {
		tft.fillRect((battIcon+1), 12, 6, 4, RED);				// If Battery is low then RED
	}    

	tft.setCursor((battx+39), 10);	
	tft.setTextColor(WHITE);
	tft.setTextSize(1);
	tft.println(display);

	/* VOLTAGE & AMPERAGE DISPLAY */

	tft.fillRect(battx, 0, 20, 18, BLACK);

	tft.setCursor(battx, 2);	
	tft.setTextColor(GREEN);
	if (vcc < 4.9) { tft.setTextColor(YELLOW); }
	if (vcc < 4.0) { tft.setTextColor(RED); }
	if (vcc >= 7) { tft.setTextColor(RED); }
	tft.setTextSize(1);
	if (vcc > 9.9) { tft.print("10+"); }
	else { tft.print(vcc,1); }
	tft.println("V");

	tft.setCursor(battx, 10);	
	tft.setTextColor(GREEN);
	if (vcc < 4.9) { tft.setTextColor(YELLOW); }
	if (vcc < 4.0) { tft.setTextColor(RED); }
	tft.setTextSize(1);
	if (vcc > 9.9) { tft.print("10+"); }
	else { tft.print(vcc,1); }
	tft.println("A");
	
}

void xbeeSL() {

	atRequest.setCommand(slCmd);  
	xbee.send(atRequest);

	if (xbee.readPacket(5000)) {						// Wait up to 5 seconds for the status response...
		// Got a response!

		xbee.getResponse().getAtCommandResponse(atResponse);			
		if (atResponse.isOk()) {
			Serial.print("Command [");
			Serial.print(atResponse.getCommand()[0]);
			Serial.print(atResponse.getCommand()[1]);
			Serial.println("] was successful!");
			xbATResponse = 0x00;
			if (atResponse.getValueLength() > 0) {
				Serial.print("Command value length is ");
				Serial.println(atResponse.getValueLength(), DEC);
				Serial.print("Command value: ");
				for (int i = 0; i < atResponse.getValueLength(); i++) {
					Serial.print(atResponse.getValue()[i], HEX);
					Serial.print(" ");
				}
				Serial.println("");
			}
		} else {
			Serial.print("Command return error code: ");
			Serial.println(atResponse.getStatus(), HEX);
		}

	} else {
		if (xbee.getResponse().isError()) {
			Serial.print("Error reading packet.  Error code: ");  
			Serial.println(xbee.getResponse().getErrorCode());
		} else {
			Serial.println("No response from radio!");  
		}
	}

}

void RXdata() {
 
	xbee.readPacket(xbeeTimeout);
	
	if (xbee.getResponse().isAvailable()) {
	
		if (xbee.getResponse().getApiId() == ZB_RX_RESPONSE) {

			lastTransmission = millis();
			if (signalCode < 2) {
				signalCode = 1;
			}

			//Serial.println("Got ZB_RX_RESPONSE...");

			xbee.getResponse().getZBRxResponse(rx);

			/*
			Serial.print("Rx:");
			Serial.print("\t");   Serial.print(rx.getData()[0]);
			Serial.print("\t");   Serial.print(rx.getData()[1]);
			Serial.print("\t");   Serial.print(rx.getData()[2]);
			Serial.print("\t");   Serial.print(rx.getData()[3]);
			Serial.print("\t");   Serial.print(rx.getData()[4]);
			Serial.print("\t"); Serial.println(rx.getData()[5]);
			Serial.println("\tReceived zbTx");
			*/

			rxVCC = rx.getData()[0];
			rxVCA = rx.getData()[1];
			rxRssi = rx.getData()[2];

			rxSignature = rx.getData()[3];
			rxResponded = rx.getData()[4];

			rxVCCout = (float)rxVCC/10.0;
			rxVCAout = (float)rxVCA/10.0;

			//Serial.print("Receiver RSSI: "); Serial.println(rxRssi);
			//Serial.print("Receiver Voltage: "); Serial.println(rxVCCout);
			//Serial.print("Receiver Amperage: "); Serial.println(rxVCAout);

			if ((signalCode == 2) && (txSignature == rxSignature)) {
//				if (verifySticky > 0) {
//					toggleStickyTrigger(verifySticky);
//					verifySticky = 0;
//				}
				signalCode = 3;
				signalNextMilli = 0;
				newSignature();
			}

		}

	}
	
}

void newSignature() {
	txSignature++;
	if (txSignature > 250) {
		txSignature = 1;
	}
}

void getVCC() {

	int VCCvalue = analogRead(analogVCCinput);
	float vout = 0.0;											// For voltage out measured analog input
	float vcc = 0.0;											// Voltage calculated, since the divider allows for 15 volts

	vout= (VCCvalue * 5.0)/1024.0;								// Voltage coming out of the voltage divider
	vcc = vout / (R2/(R1+R2));									// Voltage based on vout to display battery status
	txVCC = (vcc)*10;
	
	//Serial.print("Battery Voltage: "); Serial.println(txVCC);
	
}

void resetTuscen() {
    tuscenEventCheck=false;
    tuscenTier2Wait = false;
    zbutPressed = false;
    cbutPressed = false;
    triggerEvent = 0;
//    Serial.println("Board reset");
    updateGrid();
}

void getVCA() {
	//VCAvalue = random(1,999);
}

void TXdata() {

	byte sendSig = 0;
	if (triggerEvent > 0) {
		sendSig = txSignature;
	}

	payload[0]=joyx;			
	payload[1]=joyy;			
	payload[2]=accx;			
	payload[3]=triggerEvent;			
//	payload[4]=accz;			
//	payload[5]=zbut;			
//	payload[6]=cbut;  			
//	payload[7]=triggerEvent;	// 0 to 254
//	payload[4]=sendSig;			// Signature of triggerEvent
/*
	Serial.print("joyx: "); Serial.print((byte)joyx,DEC);
	Serial.print("\tjoyy: "); Serial.print((byte)joyy,DEC);
	Serial.print("\taccx: "); Serial.print((byte)accx,DEC);
	Serial.print("\tzbut: "); Serial.print((byte)zbut,DEC);
	Serial.print("\tcbut: "); Serial.print((byte)cbut,DEC);
*/
// if (triggerEvent!=0){	Serial.print("\ttrigger: "); Serial.println(triggerEvent);}
	
	xbee.send(zbTx);

	if (triggerEvent > 0) {
		signalCode = 2;
		signalLastSent = millis();
		signalNextMilli = 0;
		lastSigSent = txSignature;
	}
	
	triggerEvent = 0;
	zbut=0;
	cbut=0;

}  

void getTouch() {  
	
	int touchedRelativeX;
	int touchedRelativeY;

	Point p = ts.getPoint();

	//Serial.print("Registered touch, pressure: "); Serial.println(p.z);
	//sensitivity = ts.pressureThreshhold; // Default?

	if (p.z > sensitivity) {

		unsigned long timeNow = millis();

		if (timeNow >= (lastTouch+touchWait)) {

			lastTouch = timeNow;

			Serial.print("RAW X = "); Serial.print(p.x);
			Serial.print("\tY = "); Serial.print(p.y);
			Serial.print("\tPressure = "); Serial.print(p.z);
	
			// We also have to re-align LCD X&Y to Touch X&Y
			touchedY = map(p.x, TS_MINX, TS_MAXX, 240, 0);				// Notice mapping touchedY to p.x
			touchedX = map(p.y, TS_MAXY, TS_MINY, 320, 0);				// Notice mapping touchedX to p.y
	
			Serial.print("\tTouched X = "); Serial.print(touchedX);
			Serial.print("\tTouched Y = "); Serial.print(touchedY);
			Serial.println(" ");
			
			if (touchedY >= 206 && touchedX < 160) {
				curPage--;
				if (curPage < 1) { curPage = menuPages; }
				updateGrid();
			}		
	
			if (touchedY >= 206 && touchedX > 160) {
				curPage++;
				if (curPage > menuPages) { curPage = 1; }
				updateGrid();
			}		
	
			if (touchedY >= 20 && touchedY <= 205) {
	
				touchedRelativeX = touchedX;
				touchedRelativeY = touchedY-20;
	
				touchedRow = (touchedRelativeY/(186/rowsPerPage))+1;
				touchedCol = (touchedRelativeX/(320/boxesPerRow))+1;
	
				//Serial.print("Touched item: ");
				//Serial.print(touchedRow);
				//Serial.print(",");
				//Serial.print(touchedCol);
	
				triggerEvent = ((startAt+(touchedRow-1)*boxesPerRow)+touchedCol);
	
				//Serial.print(" (");
				//Serial.print(triggerEvent);
				//Serial.println(")");
	
//				int touchedSticky = getStickyTrigger(stickyTriggers, triggerEvent);
//				if (touchedSticky >= 0) {
//					verifySticky = triggerEvent;
//				}
	
			}
		}

	}

}

void updateSignal() {

	int signalLag = 600; // Meaningful signals shouldn't blink by too quick...
	unsigned long thisMilli = millis();

	if ((signalCode == 2) && (thisMilli >= signalLastSent+signalTimeout)) {
		// Timeout, give up on this signal...
		signalCode = -1;
//		verifySticky = 0;
		newSignature();
	}

	if (thisMilli >= signalNextMilli) {
		switch(signalCode) {
			case -1:
				tft.fillCircle(7, 9, 6, RED);
				break;
			case 1:
				tft.fillCircle(7, 9, 6, WHITE);
				break;	
			case 2:
				tft.fillCircle(7, 9, 6, YELLOW);
				break;	
			case 3:
				tft.fillCircle(7, 9, 6, GREEN);
				break;
			default:
				tft.fillCircle(7, 9, 6, GRAY);
		}
		if (signalCode == 3) {
			signalCode = 1;
		}
		signalNextMilli = thisMilli+signalLag;
	}

}

void checkPulse() {
	unsigned long timeNow = millis();
	if (timeNow >= (lastTransmission+signalTimeout+1000)) {
		signalCode = 0;
		signalNextMilli = 0;
		rxVCCout = 0;
		rxRssi = rssiMin;
	}
}

void initNunchuck() {
      // initialise Nunchuk
  Wire.begin();

  Wire.beginTransmission(WII_NUNCHUK_I2C_ADDRESS);
  Wire.write(0xF0);
  Wire.write(0x55);
  Wire.endTransmission();
  delay(1);

  Wire.beginTransmission(WII_NUNCHUK_I2C_ADDRESS);
  Wire.write(0xFB);
  Wire.write(0x00);
  Wire.endTransmission();  
  delay(1);

  Wire.beginTransmission(WII_NUNCHUK_I2C_ADDRESS);
  Wire.write(0x00);
  Wire.endTransmission();
}

void getNunchuckData() {
    // demanding 6 items of data from Nunchuck through I2C
    Wire.requestFrom(WII_NUNCHUK_I2C_ADDRESS, 6);

    int counter = 0;
    while(Wire.available())
    {
      nunchuckData[counter++] = Wire.read();
    }

    // Re-initializing Nunchuck after previous command
    Wire.beginTransmission(WII_NUNCHUK_I2C_ADDRESS);
    Wire.write(0x00);
    Wire.endTransmission();

    if(counter >= 5)
    {
      // extracing data
      joyx = ((nunchuckData[0] <<2) + ((nunchuckData[5] >> 2) & 0x03));
      joyy = ((nunchuckData[1] <<2) + ((nunchuckData[5] >> 2) & 0x03));
      double accelX = ((nunchuckData[2] << 2) + ((nunchuckData[5] >> 2) & 0x03) - ZEROX);
//      double accelY = ((nunchuckData[3] << 2) + ((nunchuckData[5] >> 4) & 0x03) - ZEROY); // not used
//      double accelZ = ((nunchuckData[4] << 2) + ((nunchuckData[5] >> 6) & 0x03) - ZEROZ); // not used
      zbut = !( nunchuckData[5] & B00000001);
      cbut = !((nunchuckData[5] & B00000010) >> 1);
      
      // calculating X-axis acceleration
      int value = constrain(accelX, -180, 180);
      value = map(value, -180, 180, 1, 179);       
      if (value==0||value==180){value=90;}
      accx = (180-value);
      
      joyx=map(joyx, 0, 1020, 1, 179);
      joyy=map(joyy, 0, 1020, 1, 179);

      Serial.print("accx: ");Serial.print(accx);      
      Serial.print("  \tjoyx: ");Serial.print(joyx);      
      Serial.print("  \tjoyy: ");Serial.print(joyy);      
      Serial.print("  \tcbut: ");Serial.print(cbut);      
      Serial.print("  \tzbut: ");Serial.println(zbut);      

      delay(20); // Small delay to not overcrowd nunchuck data
    }
    
}
